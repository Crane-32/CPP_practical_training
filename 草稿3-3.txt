#include "stdafx.h"
#include <graphics.h>
#include"mmsystem.h"
#pragma comment(lib,"winmm.lib")
using namespace sf;
const int W = 1920;
const int H = 1080;
float DEGTORAD = 0.017453f;

class Animation
{
public:
    float Frame, speed;
    Sprite sprite;
    std::vector<IntRect> frames;
    Animation() {}
    Animation(Texture& t, int x, int y, int w, int h, int count, float Speed)
    {
        Frame = 0;
        speed = Speed;

        for (int i = 0; i < count; i++)
            frames.push_back(IntRect(x + i * w, y, w, h));

        sprite.setTexture(t);
        sprite.setOrigin(w / 2, h / 2);
        sprite.setTextureRect(frames[0]);
    }

    void update()
    {
        Frame += speed;
        int n = frames.size();
        if (Frame >= n) Frame -= n;
        if (n > 0) sprite.setTextureRect(frames[int(Frame)]);
    }

    bool isEnd()
    {
        return Frame + speed >= frames.size();
    }

};

class Entity
{
public:
    float x, y, dx, dy, R, angle;
    bool life;
    std::string name;
    Animation anim;

    Entity()
    {
        life = 1;
    }

    void settings(Animation& a, int X, int Y, float Angle = 0, int radius = 1)
    {
        anim = a;
        x = X; y = Y;
        angle = Angle;
        R = radius;
    }

    virtual void update() {};

    void draw(RenderWindow& app)
    {
        anim.sprite.setPosition(x, y);
        anim.sprite.setRotation(angle + 90);
        app.draw(anim.sprite);

        CircleShape circle(R);
        circle.setFillColor(Color(255, 0, 0, 170));
        circle.setPosition(x, y);
        circle.setOrigin(R, R);
        //app.draw(circle);
    }
    virtual ~Entity() {};
};

class asteroid : public Entity
{
public:
    asteroid()
    {
        dx = rand() % 8 - 4;
        dy = rand() % 8 - 4;
        name = "asteroid";
    }

    void update()
    {
        x += dx;
        y += dy;

        if (x > W) x = 0;  if (x < 0) x = W;
        if (y > H) y = 0;  if (y < 0) y = H;
    }

};

class bullet : public Entity
{
public:
    bullet()
    {
        name = "bullet";
    }

    void  update()
    {
        dx = cos(angle * DEGTORAD) * 4;
        dy = sin(angle * DEGTORAD) * 4;
        x += dx;
        y += dy;
        if (x > W || x<0 || y>H || y < 0) life = 0;
    }
};
class bullet2 : public Entity
{
public:
    bullet2()
    {
        name = "bullet2";
    }
    void  update()
    {
        dx = cos(angle * DEGTORAD) * 10;
        dy = sin(angle * DEGTORAD) * 10;
        angle += rand() % 7 - 3;  /*try this*/
        x += dx;
        y += dy;

        if (x > W || x<0 || y>H || y < 0) life = 0;
    }

};

class player : public Entity
{
public:
    bool thrust;

    player()
    {
        name = "player";
    }

    void update()
    {
        if (thrust)
        {
            dx += cos(angle * DEGTORAD) * 0.2;
            dy += sin(angle * DEGTORAD) * 0.2;
        }
        else
        {
            dx *= 0.99;
            dy *= 0.99;
        }

        int maxSpeed = 15;
        float speed = sqrt(dx * dx + dy * dy);
        if (speed > maxSpeed)
        {
            dx *= maxSpeed / speed;
            dy *= maxSpeed / speed;
        }

        x += dx;
        y += dy;

        if (x > W) x = 0; if (x < 0) x = W;
        if (y > H) y = 0; if (y < 0) y = H;
    }

};

bool isCollide(Entity* a, Entity* b)
{
    return (b->x - a->x) * (b->x - a->x) +
        (b->y - a->y) * (b->y - a->y) <
        (a->R + b->R) * (a->R + b->R);
}

class Button
{
public:
    RenderWindow* window;
    Texture sprite_name;
    SoundBuffer audio_name;
    int pos_x, pos_y, size_x, size_y;
    Sprite button;
    Sound button_music;
    Button(RenderWindow* w) :window(w) {};
    void setButtonSize(float x, float y)
    {
        size_x = x; size_y = y;
        Vector2u true_size;
        true_size = sprite_name.getSize();
        x = x / true_size.x;
        y = y / true_size.y;
        button.setScale(Vector2f(x, y));
    }
    void setButtonPos(int x, int y)
    {
        pos_x = x; pos_y = y;
        button.setPosition(x, y);
    }
    void setAudio(String s)
    {
        audio_name.loadFromFile(s);
        button_music.setBuffer(audio_name);
    }
    void setSprite(String s)
    {
        sprite_name.loadFromFile(s);
        sprite_name.setSmooth(true);
        button.setTexture(sprite_name);
    }
    int buttonPressed();
    void show()
    {
        (*window).draw(button);
    }
    void show(String s_sprite, String s_music, int x, int y, float w, float h)
    {
        setSprite(s_sprite);
        setAudio(s_music);
        setButtonSize(w, h);
        setButtonPos(x, y);
        (*window).draw(button);
    }
};
int Button::buttonPressed()
{
    Vector2i pos = Mouse::getPosition((*window));
    Event e;
    while ((*window).pollEvent(e))
    {
        if (e.type = Event::Closed)
        {
            (*window).close(); return -1;
        }
        if (e.type = Event::MouseButtonPressed)
            if (pos.x >= pos_x && pos.x <= pos_x + size_x && pos.y >= pos_y && pos.y <= pos_y + size_y)
                if (e.key.code == Mouse::Left)
                {
                    /*
                    clock_t start, ends;
                    start = clock();
                    ends = clock();
                    Event e1;
                    while (ends - start < 500)
                    {
                        (*window).pollEvent(e1);
                        ends = clock();
                        if (e1.type == Event::MouseButtonPressed && e1.key.code = Mouse::Left)
                            return 2;//双击左键
                    }
                    std::cout << "......" << std::endl;
                    Sleep(400);
                    */
                    return 1;//单击左键
                }
                else if (e.key.code == Mouse::Right)return 3;//单击右键
                else return 0;
    }
}

int start()
{
    initgraph(1920, 1080);
    system("color 4");
    mciSendString(TEXT("open appletree.mp3 alias mysong"), NULL, 0, NULL);
    mciSendString(TEXT("play MySong repeat"), NULL, 0, NULL);
    loadimage(NULL, _T("images/main.jpg"), 0, 0, false);
    setbkmode(TRANSPARENT);
    int k;
    settextcolor(RGB(100, 149, 237));
    settextstyle(64, 0, _T("Consolas"));
    outtextxy(0, 40, _T("必将实现的道路——太阳系的共产主义未来"));
    settextcolor(RGB(198, 226, 255));
    settextstyle(40, 0, _T("Impact"));
    outtextxy(190, 100, _T("powered&developed by:门门挂科的山山"));
    settextstyle(40, 0, _T("Impact"));
    roundrect(320, 280, 640, 320, 5, 5);
    roundrect(320, 330, 640, 370, 5, 5);
    roundrect(320, 380, 640, 420, 5, 5);
    roundrect(320, 430, 640, 470, 5, 5);
    roundrect(320, 480, 640, 520, 5, 5);

    settextstyle(36, 0, _T("Consolas"), 0, 0, 0, false, false, false);
    outtextxy(320, 280, _T("开始新游戏"));
    outtextxy(320, 330, _T("读取存档"));
    outtextxy(320, 380, _T("帮助"));
    outtextxy(320, 430, _T("高分"));
    outtextxy(320, 480, _T("退出"));
    settextcolor(RGB(100, 149, 237));

    while (1)
    {
        MOUSEMSG m = GetMouseMsg();
        settextcolor(RGB(255, 179, 166));
        if (m.x < 640 && m.x>320 && m.y < 320 && m.y>280)
        {           
            outtextxy(320, 280, _T("开始新游戏"));
            if (m.uMsg == WM_LBUTTONDOWN) { k = 1; break; }
        }
        else if (m.x < 640 && m.x>320 && m.y < 370 && m.y>330)
        {           
            outtextxy(320, 330, _T("读取存档"));
            if (m.uMsg == WM_LBUTTONDOWN) { k = 2; break; }
        }
        else if (m.x < 640 && m.x>320 && m.y < 420 && m.y>380)
        {
            outtextxy(320, 380, _T("帮助"));
            if (m.uMsg == WM_LBUTTONDOWN) { k = 3; break; }
        }
        else if (m.x < 640 && m.x>320 && m.y < 470 && m.y>430)
        {
            outtextxy(320, 430, _T("高分"));
            if (m.uMsg == WM_LBUTTONDOWN) { k = 4; break; }
        }
        else if (m.x < 640 && m.x>320 && m.y < 520 && m.y>480)
        {
            outtextxy(320, 480, _T("退出"));
            if (m.uMsg == WM_LBUTTONDOWN) { k = 5; break; }
        }
        else
        {
            settextcolor(RGB(100, 149, 237));
            outtextxy(320, 280, _T("开始新游戏"));
            outtextxy(320, 330, _T("读取存档"));
            outtextxy(320, 380, _T("帮助"));
            outtextxy(320, 430, _T("高分"));
            outtextxy(320, 480, _T("退出"));
        }
        FlushMouseMsgBuffer();
    }
    mciSendString(TEXT("stop mysong"), NULL, 0, NULL);
    mciSendString(TEXT("close mysong"), NULL, 0, NULL);
    return k;
    closegraph();
}

int help()
{
    RenderWindow apph(VideoMode(W, H), L"天问之旅——游戏帮助");
    apph.setFramerateLimit(60);
    Texture t1, t2;
    t1.loadFromFile("images/help.png"); t1.setSmooth(true);
    t2.loadFromFile("images/help.jpg"); t2.setSmooth(true);
    Sprite ex(t1);
    Sprite help(t2);
    ex.setPosition(800.0, 750.0);
    std::list<Entity*> entities;

    sf::Music musich;
    if (!musich.openFromFile("youth.ogg"))
        return -1;
    musich.play();
    while (apph.isOpen())
    {
        Event event;
        while (apph.pollEvent(event))
        {
            if (event.type == Event::Closed)
                apph.close();
            if (event.type == Event::MouseButtonPressed)
            {
                Vector2i pos;
                pos=Mouse::getPosition();
                if (pos.x >= 800 && pos.x <= 1120 && pos.y >= 750 && pos.y <= 930)
                    if (event.key.code == Mouse::Left)
                    {
                        apph.close(); 
                        return 0;//单击左键
                    }
            }
        }
        apph.draw(help);
        apph.draw(ex);
        apph.display();
    }
}

int main()
{
     srand(time(0));
ZZ:
    int k = start();
    switch (k)
    {
    case 1: goto AA; break;
    default: return 0;
    }
    if (k == 1)
    {
        goto AA;
    }

AA:
    RenderWindow app(VideoMode(W, H), L"天问之旅");
    app.setFramerateLimit(60);

    Texture t1, t2, t3, t4, t5, t52, t6, t7;
    t1.loadFromFile("images/spaceship.png"); t1.setSmooth(true);
    t2.loadFromFile("images/background.jpg"); t2.setSmooth(true);
    t3.loadFromFile("images/explosions/type_C.png");
    t4.loadFromFile("images/rock.png");
    t5.loadFromFile("images/fire_red.png");
    t52.loadFromFile("images/fire_blue.png");
    t6.loadFromFile("images/rock_small.png");
    t7.loadFromFile("images/explosions/type_B.png");

    Animation sExplosion(t3, 0, 0, 256, 256, 48, 0.5);
    Animation sRock(t4, 0, 0, 64, 64, 16, 0.2);
    Animation sRock_small(t6, 0, 0, 64, 64, 16, 0.2);
    Animation sBullet(t5, 0, 0, 32, 64, 16, 0.8);
    Animation sBullet2(t52, 0, 0, 32, 64, 16, 0.8);
    Animation sPlayer(t1, 40, 0, 40, 40, 1, 0);
    Animation sPlayer_go(t1, 40, 40, 40, 40, 1, 0);
    Animation sExplosion_ship(t7, 0, 0, 192, 192, 64, 0.5);
    Sprite background(t2);

    std::list<Entity*> entities;

    for (int i = 0; i < 15; i++)
    {
        asteroid* a = new asteroid();
        a->settings(sRock, rand() % W, rand() % H, rand() % 360, 25);
        entities.push_back(a);
    }
    player* p = new player();
    p->settings(sPlayer, W / 2, H / 2, 0, 20);
    entities.push_back(p);

    sf::Music music1;
    if (!music1.openFromFile("youth.ogg"))
        return -1;
    //music1.setVolume(20);
    music1.play();
    //main loop
    while (app.isOpen())
    {
        //int sleep1, sleep2;
        //clock_t start, ends;
        //start = clock();
        //ends = clock()-1000;
        Event event;
        while (app.pollEvent(event))
        {
            if (event.type == Event::Closed)
                app.close();
            if (event.type == Event::KeyPressed)

                if (event.key.code == Keyboard::E)
                {
                    bullet2* b = new bullet2();
                    b->settings(sBullet2, p->x, p->y, p->angle, 80);
                    entities.push_back(b);

                    /*
                    //sf::SoundBuffer sBuffer;
                    //if (!sBuffer.loadFromFile("mySound.ogg"))
                    //    return -1;
                    //sf::Sound sound(sBuffer);
                    
                    for (int i = 0; i < 5; i++)
                    {
                        bullet2* b = new bullet2();
                        b->settings(sBullet2, p->x, p->y, p->angle+72*i, 80);
                        entities.push_back(b);
                    }
                    */
               }
            if (event.key.code == Keyboard::Q)
            {
                bullet* b0 = new bullet(); b0->settings(sBullet, p->x, p->y, p->angle, 20); entities.push_back(b0);
                bullet* b1 = new bullet(); b1->settings(sBullet, p->x, p->y, p->angle + 10, 20); entities.push_back(b1);
                bullet* b2 = new bullet(); b2->settings(sBullet, p->x, p->y, p->angle + 20, 20); entities.push_back(b2);
                bullet* b3 = new bullet(); b3->settings(sBullet, p->x, p->y, p->angle + 30, 20); entities.push_back(b3);
                bullet* b4 = new bullet(); b4->settings(sBullet, p->x, p->y, p->angle + 40, 20); entities.push_back(b4);
                bullet* b5 = new bullet(); b5->settings(sBullet, p->x, p->y, p->angle + 50, 20); entities.push_back(b5);
                bullet* b6 = new bullet(); b6->settings(sBullet, p->x, p->y, p->angle + 60, 20); entities.push_back(b6);
                bullet* b7 = new bullet(); b7->settings(sBullet, p->x, p->y, p->angle + 70, 20); entities.push_back(b7);
                bullet* b8 = new bullet(); b8->settings(sBullet, p->x, p->y, p->angle + 80, 20); entities.push_back(b8);
                bullet* b9 = new bullet(); b9->settings(sBullet, p->x, p->y, p->angle + 90, 20); entities.push_back(b9);
                bullet* b10 = new bullet(); b10->settings(sBullet, p->x, p->y, p->angle + 100, 20); entities.push_back(b10);
                bullet* b11 = new bullet(); b11->settings(sBullet, p->x, p->y, p->angle + 110, 20); entities.push_back(b11);
                bullet* b12 = new bullet(); b12->settings(sBullet, p->x, p->y, p->angle + 120, 20); entities.push_back(b12);
                bullet* b13 = new bullet(); b13->settings(sBullet, p->x, p->y, p->angle + 130, 20); entities.push_back(b13);
                bullet* b14 = new bullet(); b14->settings(sBullet, p->x, p->y, p->angle + 140, 20); entities.push_back(b14);
                bullet* b15 = new bullet(); b15->settings(sBullet, p->x, p->y, p->angle + 150, 20); entities.push_back(b15);
                bullet* b16 = new bullet(); b16->settings(sBullet, p->x, p->y, p->angle + 160, 20); entities.push_back(b16);
                bullet* b17 = new bullet(); b17->settings(sBullet, p->x, p->y, p->angle + 170, 20); entities.push_back(b17);
                bullet* b18 = new bullet(); b18->settings(sBullet, p->x, p->y, p->angle + 180, 20); entities.push_back(b18);
                bullet* b19 = new bullet(); b19->settings(sBullet, p->x, p->y, p->angle + 190, 20); entities.push_back(b19);
                bullet* b20 = new bullet(); b20->settings(sBullet, p->x, p->y, p->angle + 200, 20); entities.push_back(b20);
                bullet* b21 = new bullet(); b21->settings(sBullet, p->x, p->y, p->angle + 210, 20); entities.push_back(b21);
                bullet* b22 = new bullet(); b22->settings(sBullet, p->x, p->y, p->angle + 220, 20); entities.push_back(b22);
                bullet* b23 = new bullet(); b23->settings(sBullet, p->x, p->y, p->angle + 230, 20); entities.push_back(b23);
                bullet* b24 = new bullet(); b24->settings(sBullet, p->x, p->y, p->angle + 240, 20); entities.push_back(b24);
                bullet* b25 = new bullet(); b25->settings(sBullet, p->x, p->y, p->angle + 250, 20); entities.push_back(b25);
                bullet* b26 = new bullet(); b26->settings(sBullet, p->x, p->y, p->angle + 260, 20); entities.push_back(b26);
                bullet* b27 = new bullet(); b27->settings(sBullet, p->x, p->y, p->angle + 270, 20); entities.push_back(b27);
                bullet* b28 = new bullet(); b28->settings(sBullet, p->x, p->y, p->angle + 280, 20); entities.push_back(b28);
                bullet* b29 = new bullet(); b29->settings(sBullet, p->x, p->y, p->angle + 290, 20); entities.push_back(b29);
                bullet* b30 = new bullet(); b30->settings(sBullet, p->x, p->y, p->angle + 300, 20); entities.push_back(b30);
                bullet* b31 = new bullet(); b31->settings(sBullet, p->x, p->y, p->angle + 310, 20); entities.push_back(b31);
                bullet* b32 = new bullet(); b32->settings(sBullet, p->x, p->y, p->angle + 320, 20); entities.push_back(b32);
                bullet* b33 = new bullet(); b33->settings(sBullet, p->x, p->y, p->angle + 330, 20); entities.push_back(b33);
                bullet* b34 = new bullet(); b34->settings(sBullet, p->x, p->y, p->angle + 340, 20); entities.push_back(b34);
                bullet* b35 = new bullet(); b35->settings(sBullet, p->x, p->y, p->angle + 350, 20); entities.push_back(b35);
            }
            if (event.type == Event::KeyPressed)
            {
                if (Keyboard::isKeyPressed(Keyboard::Right)) p->angle += 5;
                if (Keyboard::isKeyPressed(Keyboard::Left))  p->angle -= 5;
                if (Keyboard::isKeyPressed(Keyboard::Up)) p->thrust = true;
            }
            else p->thrust = false;
        }

        for (auto a : entities)
            for (auto b : entities)
            {
                if (a->name == "asteroid" && b->name == "bullet")
                    if (isCollide(a, b))
                    {
                        a->life = false;
                        b->life = false;

                        Entity* e = new Entity();
                        e->settings(sExplosion, a->x, a->y);
                        e->name = "explosion";
                        entities.push_back(e);
                        for (int i = 0; i < rand() % 5 + 2; i++)
                        {
                            if (a->R == 15) continue;
                            Entity* e = new asteroid();
                            e->settings(sRock_small, a->x, a->y, rand() % 360, 15);
                            entities.push_back(e);
                        }

                    }
                if (a->name == "asteroid" && b->name == "bullet2")
                    if (isCollide(a, b))
                    {
                        a->life = false;
                        b->life = false;

                        Entity* e = new Entity();
                        e->settings(sExplosion, a->x, a->y);
                        e->name = "explosion";
                        entities.push_back(e);
                        for (int i = 0; i < rand() % 5 + 2; i++)
                        {
                            if (a->R == 15) continue;
                            Entity* e = new asteroid();
                            e->settings(sRock_small, a->x, a->y, rand() % 360, 15);
                            entities.push_back(e);
                        }

                    }

                if (a->name == "player" && b->name == "asteroid")
                    if (isCollide(a, b))
                    {
                        b->life = false;

                        Entity* e = new Entity();
                        e->settings(sExplosion_ship, a->x, a->y);
                        e->name = "explosion";
                        entities.push_back(e);

                        p->settings(sPlayer, W / 2, H / 2, 0, 20);
                        p->dx = 0; p->dy = 0;
                    }
            }

        if (p->thrust)  p->anim = sPlayer_go;
        else   p->anim = sPlayer;

        for (auto e : entities)
            if (e->name == "explosion")
                if (e->anim.isEnd()) e->life = 0;

        if (rand() % 150 == 0)
        {
            asteroid* a = new asteroid();
            a->settings(sRock, 0, rand() % H, rand() % 360, 25);
            entities.push_back(a);
        }

        for (auto i = entities.begin(); i != entities.end();)
        {
            Entity* e = *i;

            e->update();
            e->anim.update();

            if (e->life == false) { i = entities.erase(i); delete e; }
            else i++;
        }

        //draw
        app.draw(background);
        for (auto i : entities) i->draw(app);
        app.display();

        //bt01.show();
    }
    goto ZZ;
    return 0;
}

